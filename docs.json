{
  "timestamp": "2025-03-07T14:21:36",
  "compiler": {
    "name": "@stencil/core",
    "version": "2.19.3",
    "typescriptVersion": "4.7.4"
  },
  "components": [
    {
      "filePath": "./src/components/gataca-autoqr/gataca-autoqr.tsx",
      "encapsulation": "shadow",
      "tag": "gataca-autoqr",
      "readme": "# Gataca-AutoQR\n\nThis component built using stencyl allows an easy integration to display a GatacaQR using a predefined generated config that is downloaded when the component is displayed.\n\nAn AutoQR Config has the following structure:\n\n```typescript\nexport type QRConfig = {\n  useButton: boolean;\n  useWs: boolean;\n\n  //To display any QR\n  qrModalTitle?: string;\n  qrModalDescription?: string;\n  hideBrandTitle?: boolean;\n\n  successCallback: (data?: any) => void;\n  errorCallback: (error?: Error) => void;\n\n  autostart: boolean;\n  autorefresh: boolean;\n  sessionTimeout?: number;\n\n  qrRole: string;\n  callbackServer: string;\n  v?: string;\n  dynamicLink?: boolean;\n\n  //Just for Polling\n  checkStatus?: (id?: string) => Promise<{ result: RESULT_STATUS; data?: any }>;\n  createSession?: () => Promise<{\n    sessionId: string;\n    authenticationRequest?: string;\n  }>;\n  pollingFrequency?: number;\n\n  //Just for WS\n  socketEndpoint: string;\n  wsOnOpen?: (socket: WebSocket) => void;\n  wsOnMessage?: (socket: WebSocket, msg: MessageEvent) => void;\n\n  //Just for Buttons\n  buttonText?: string;\n};\n```\n\nDepending on the parameters **useWs** and **useButton**, it will automatically load the corresponding component of the 4 possible options, with all the configuration loaded.\n\n| **useButton** \\ **useWs**        | _false_: Using Polling                            | _true_: Using Websockets                              |\n| -------------------------------- | ------------------------------------------------- | ----------------------------------------------------- |\n| _false_: Displaying the QR       | [Gataca QR](../gataca-qr/readme.md)               | [Gataca QRWS](../gataca-qrws/readme.md)               |\n| _true_: Displaying an SSI Button | [Gataca SSIButton](../gataca-ssibutton/readme.md) | [Gataca SSIButtonWS](../gataca-ssibuttonws/readme.md) |\n\n## Integrations\n\nFor integration, just refer to the documentation of the selected component.\n\nIt is noted that while supported on the config, it is RECOMMENDED that the function parameters are defined and implemented locally when inserting the autoqr component. Defining them remotely will allow for remote code injection.\n\n#### Example\n\nLook for the best suitable example on each of the components.\n\nThe pure JS integration of the most basic case, with polling and without button, could look like this:\n\n```html\n<!DOCTYPE html>\n<html dir=\"ltr\" lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=5.0\"\n    />\n    <title>Gataca Auto QR Component</title>\n    <script type=\"module\" src=\"/build/gatacaqr.esm.js\"></script>\n    <script nomodule src=\"/build/gatacaqr.js\"></script>\n  </head>\n  <body>\n    <div>\n      <gataca-autoqr id=\"gataca-qr\" configId=\"your_config_id\">\n        <!-- TODO Change with your config id-->\n      </gataca-autoqr>\n    </div>\n\n    <script>\n      const qr = document.getElementById(\"gataca-qr\");\n      var count = 0;\n      var ok = true;\n\n      qr.successCallback = (data) => {\n        //TODO Change with what you want to happen when the session is validated\n        alert(\"ALL OK\" + data);\n      };\n      qr.errorCallback = () => {\n        //TODO Change with what you want to happen when the session is expired or the user provides invalid credentials\n        alert(\"some error\");\n      };\n\n      qr.createSession = () => {\n        // Authentication request is required\n        return {\n          sessionId: \"TWp3V2R1N29ZcmFMY3Nvd3ZPb3k0UlMz\",\n          authenticationRequest: \"\",\n        };\n      };\n\n      qr.checkStatus = () => {\n        //TODO Change with and invocation to your Backend service to query the status of the session\n        count++;\n        if (count == 10) {\n          return { result: ok ? 1 : 2, data: { name: \"test\", token: \"x\" } };\n        }\n        return { result: 0 };\n      };\n    </script>\n  </body>\n</html>\n```\n",
      "docs": "This component built using stencyl allows an easy integration to display a GatacaQR using a predefined generated config that is downloaded when the component is displayed.\n\nAn AutoQR Config has the following structure:\n\n```typescript\nexport type QRConfig = {\n  useButton: boolean;\n  useWs: boolean;\n\n  //To display any QR\n  qrModalTitle?: string;\n  qrModalDescription?: string;\n  hideBrandTitle?: boolean;\n\n  successCallback: (data?: any) => void;\n  errorCallback: (error?: Error) => void;\n\n  autostart: boolean;\n  autorefresh: boolean;\n  sessionTimeout?: number;\n\n  qrRole: string;\n  callbackServer: string;\n  v?: string;\n  dynamicLink?: boolean;\n\n  //Just for Polling\n  checkStatus?: (id?: string) => Promise<{ result: RESULT_STATUS; data?: any }>;\n  createSession?: () => Promise<{\n    sessionId: string;\n    authenticationRequest?: string;\n  }>;\n  pollingFrequency?: number;\n\n  //Just for WS\n  socketEndpoint: string;\n  wsOnOpen?: (socket: WebSocket) => void;\n  wsOnMessage?: (socket: WebSocket, msg: MessageEvent) => void;\n\n  //Just for Buttons\n  buttonText?: string;\n};\n```\n\nDepending on the parameters **useWs** and **useButton**, it will automatically load the corresponding component of the 4 possible options, with all the configuration loaded.\n\n| **useButton** \\ **useWs**        | _false_: Using Polling                            | _true_: Using Websockets                              |\n| -------------------------------- | ------------------------------------------------- | ----------------------------------------------------- |\n| _false_: Displaying the QR       | [Gataca QR](../gataca-qr/readme.md)               | [Gataca QRWS](../gataca-qrws/readme.md)               |\n| _true_: Displaying an SSI Button | [Gataca SSIButton](../gataca-ssibutton/readme.md) | [Gataca SSIButtonWS](../gataca-ssibuttonws/readme.md) |",
      "docsTags": [],
      "usage": {},
      "props": [
        {
          "name": "checkStatus",
          "type": "(id?: string) => Promise<{ result: RESULT_STATUS; data?: any; }>",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "___Just for polling flavour___\n***Mandatory***\nCheck status function to query the current status of the session\nThe function must query a client endpoint to check the status. That endpoint must return an error if the session has expired.",
          "docsTags": [],
          "default": "undefined",
          "values": [
            {
              "type": "(id?: string) => Promise<{ result: RESULT_STATUS; data?: any; }>"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "configId",
          "type": "string",
          "mutable": false,
          "attr": "config-id",
          "reflectToAttr": false,
          "docs": "***Mandatory***\nID of the QR configuration to display",
          "docsTags": [],
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "configRepository",
          "type": "string",
          "mutable": false,
          "attr": "config-repository",
          "reflectToAttr": false,
          "docs": "___Optional___\nConfigURL Repository to download the config from",
          "docsTags": [],
          "default": "DEFAULT_REPOSITORY",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "createSession",
          "type": "() => Promise<{ sessionId: string; authenticationRequest?: string; }>",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "***Mandatory***\nCreate session function to generate a new Session\nUsing v=\"3\", it can provide just a session Id\nUsing another version, it must provide also the authentication request. The session Id is the id of the presentation definition",
          "docsTags": [],
          "default": "undefined",
          "values": [
            {
              "type": "() => Promise<{ sessionId: string; authenticationRequest?: string; }>"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "errorCallback",
          "type": "(error?: Error) => void",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "___Just for polling flavour___\n***Mandatory***\nCallback fired upon session expired or invalid\nIf not set, session error would not be handled\nAn error containing information will be passed as parameter",
          "docsTags": [],
          "default": "undefined",
          "values": [
            {
              "type": "(error?: Error) => void"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "successCallback",
          "type": "(data?: any) => void",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "***Mandatory***\nCallback fired upon session correctly verified\nIf not set, session validation wouldn't trigger any action\nThe session data and a possible token will be sent as parameters to the callback",
          "docsTags": [],
          "default": "undefined",
          "values": [
            {
              "type": "(data?: any) => void"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "wsOnMessage",
          "type": "(socket: WebSocket, msg: MessageEvent<any>) => void",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "___Just for WS flavour___\n**RECOMMENDED**\nCallback to invoke an a message has been received on the socket. It provides the socket itself and the message as parameters.\nIf not used, the messages provided by the server on the Socket connection must conform to the WSReponse interface\nIf used, an Event named **sessionMsg** must be triggered with a WSReponse as data",
          "docsTags": [],
          "values": [
            {
              "type": "(socket: WebSocket, msg: MessageEvent<any>) => void"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "wsOnOpen",
          "type": "(socket: WebSocket) => void",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "___Just for WS flavour___\n[Optional]\nFunction to send a message to the server upon socket creation",
          "docsTags": [],
          "values": [
            {
              "type": "(socket: WebSocket) => void"
            }
          ],
          "optional": false,
          "required": false
        }
      ],
      "methods": [
        {
          "name": "getSessionData",
          "returns": {
            "type": "Promise<any>",
            "docs": ""
          },
          "signature": "getSessionData() => Promise<any>",
          "parameters": [],
          "docs": "Retrieve manually the session data on a successful login",
          "docsTags": []
        }
      ],
      "events": [
        {
          "event": "gatacaLoginCompleted",
          "detail": "any",
          "bubbles": true,
          "cancelable": true,
          "composed": true,
          "docs": "GatacaLoginCompleted event, triggered with session data upon login success",
          "docsTags": []
        },
        {
          "event": "gatacaLoginFailed",
          "detail": "any",
          "bubbles": true,
          "cancelable": true,
          "composed": true,
          "docs": "GatacaLoginFailed event, triggered with error upon login failure",
          "docsTags": []
        }
      ],
      "listeners": [],
      "styles": [],
      "slots": [],
      "parts": [],
      "dependents": [],
      "dependencies": [
        "gataca-ssibuttonws",
        "gataca-ssibutton",
        "gataca-qrws",
        "gataca-qr"
      ],
      "dependencyGraph": {
        "gataca-autoqr": [
          "gataca-ssibuttonws",
          "gataca-ssibutton",
          "gataca-qrws",
          "gataca-qr"
        ],
        "gataca-ssibuttonws": [
          "gataca-qrws"
        ],
        "gataca-qrws": [
          "gataca-qrdisplay"
        ],
        "gataca-ssibutton": [
          "gataca-qr"
        ],
        "gataca-qr": [
          "gataca-qrdisplay"
        ]
      }
    },
    {
      "filePath": "./src/components/gataca-qr/gataca-qr.tsx",
      "encapsulation": "shadow",
      "tag": "gataca-qr",
      "readme": "# Gataca-QR\n\nThis component built using stencyl allows an easy integration to display a gataca QR to be read by the wallet.\n\nThis component can be used with the prerequisite of having an application which can be integrated with GATACA Components: Connect and Certify. More precisely, your application will need to be able to perform the two operations against your connect or certify servers:\n\n1. Create sessions\n2. Consult sessions\n\n## Integrations\n\n### Pure JS\n\nYou can include the components by importing the library, available on NPM:\n\n#### Script tag\n\nPut a script tag similar to the source [https://unpkg.com/gatacaqr/dist/gatacaqr.js](https://unpkg.com/gatacaqr/dist/gatacaqr.js) in the head of your index.html. Check for the last version:\n\n```html\n<!DOCTYPE html>\n<html dir=\"ltr\" lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=5.0\"\n    />\n    <script\n      type=\"module\"\n      src=\"https://unpkg.com/@gataca/qr@2.0.1/dist/gatacaqr/gatacaqr.esm.js\"\n    ></script>\n    <script\n      nomodule=\"\"\n      src=\"https://unpkg.com/@gataca/qr@2.0.1/dist/index.js\"\n    ></script>\n  </head>\n  ...\n</html>\n```\n\n#### Example\n\n```html\n<!DOCTYPE html>\n<html dir=\"ltr\" lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=5.0\"\n    />\n    <title>Gataca QR Component</title>\n    <script\n      type=\"module\"\n      src=\"https://unpkg.com/@gataca/qr@2.0.1/dist/gatacaqr/gatacaqr.esm.js\"\n    ></script>\n    <script\n      nomodule=\"\"\n      src=\"https://unpkg.com/@gataca/qr@2.0.1/dist/index.js\"\n    ></script>\n  </head>\n  <body>\n    <div>\n      <gataca-qr\n        id=\"gataca-qr\"\n        qrRole=\"connect\"\n        callback-server=\"https://connect.gataca.io\"\n      >\n        <!-- TODO Change with your connect server-->\n      </gataca-qr>\n    </div>\n\n    <script>\n      const qr = document.getElementById(\"gataca-qr\");\n      var count = 0;\n      var ok = true;\n\n      qr.successCallback = (data) => {\n        //TODO Change with what you want to happen when the session is validated\n        alert(\"ALL OK\" + data);\n      };\n      qr.errorCallback = () => {\n        //TODO Change with what you want to happen when the session is expired or the user provides invalid credentials\n        alert(\"some error\");\n      };\n\n      qr.createSession = () => {\n        // Authentication request is required\n        return {\n          sessionId: \"TWp3V2R1N29ZcmFMY3Nvd3ZPb3k0UlMz\",\n          authenticationRequest: \"\",\n        };\n      };\n\n      qr.checkStatus = () => {\n        //TODO Change with and invocation to your Backend service to query the status of the session\n        count++;\n        if (count == 10) {\n          return { result: ok ? 1 : 2, data: { name: \"test\", token: \"x\" } };\n        }\n        return { result: 0 };\n      };\n    </script>\n  </body>\n</html>\n```\n\nYou can use this component with an already created session, which can be inserted on the sessionId property on the element, or passed via query parameter _id_ or _sessionId_ on the current URL.\nYou can also provide a method to generate a new session like in the example, or, in the rare event of matching the authorizer API, just the endpoint to your application.\n\nIn order to consult sessions, both options are also available, depending on how you want to develop your own API.\n\n### React App Integration\n\nImport the library\n\n```bash\nnpm install @gataca/qr --save\n```\n\nor\n\n```bash\nyarn add @gataca/qr\n```\n\nIn your base file index.js (or index.tsx), include:\n\n```typescript\nimport { applyPolyfills, defineCustomElements } from \"@gataca/qr/loader\";\n\n//before ReactDOM.render\napplyPolyfills().then(() => {\n  defineCustomElements(window);\n});\n```\n\nThe integration would depend if your using a Class Component or a Function Component. Supposing a function component (adaptation to class components is trivial), you would need to include:\n\n```typescript\ntype MyProps = {\n    ...\n    verifier?: boolean\n    configId?: string\n    appToken?: string\n}\n\n\nexport const dummyComponent: React.FC<MyProps> = (props) => {\n  ...\n  const { verifier, appToken, configId } = props\n  const qr = useRef(null)\n  let gqr: HTMLGatacaQrElement | undefined\n\n  useEffect(() => {\n            if (qr != null && qr.current != null) {\n                gqr = qr.current! as HTMLGatacaQrElement\n                gqr.createSession = createSession\n                gqr.checkStatus = checkStatus\n                gqr.successCallback = createSessionSuccess\n                gqr.errorCallback = createSessionError\n        }\n    })\n\n\n    //TODO Implement your own service logic invocation. This is just a dummy mimicking the Connect/Certify v1 APIs asuming you get an app token in props\n     const createSession = async (): Promise<{\n        sessionId: string\n        authenticationRequest?: string\n    }> => {\n        try {\n            let endpoint =\n                server +\n                (verifier ? '/api/v1/sessions' : '/api/v1/issuanceRequests')\n            let response = await fetch(endpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    Authorization: 'jwt ' + appToken,\n                },\n                body: verifier\n                    ? '{\"ssiConfigId\": \"' + configId + '\"}'\n                    : '{\"group\": \"' + configId + '\"}',\n            })\n            let data = await response.json()\n            return { sessionId: data.id! }\n        } catch (error) {\n            setSessionErrorState(true)\n            throw error\n        }\n    }\n\n    const checkStatus = async (): Promise<{\n        result: RESULT_STATUS\n        data?: any\n    }> => {\n        //TODO Implement your own service logic invocation. This is just a dummy mimicking the Connect/Certify v1 APIs asuming you get an app token in props\n        if (!appToken || error) {\n            gqr?.stop()\n        }\n        const endpoint =\n            server +\n            (verifier ? '/api/v1/sessions/' : '/admin/v1/issuanceRequests/') +\n            sessionId\n        let response = await fetch(endpoint, {\n            method: 'GET',\n            headers: {\n                Authorization: 'jwt ' + appToken,\n                'Content-Type': 'application/json',\n            },\n        })\n\n        if (verifier) {\n            let req = await response\n            return req.status === 200\n                ? { result: RESULT_STATUS.SUCCESS }\n                : req.status === 204\n                ? { result: RESULT_STATUS.ONGOING }\n                : { result: RESULT_STATUS.FAILED }\n        } else {\n            let req = await response.json()\n            return !req.status || req.status === 'PENDING'\n                ? { result: RESULT_STATUS.ONGOING }\n                : req.status === 'INVALID'\n                ? { result: RESULT_STATUS.FAILED }\n                : { result: RESULT_STATUS.SUCCESS }\n        }\n    }\n\n    const createSessionSuccess = (newdata: any) => {\n        //TODO Handle success\n    }\n\n    const createSessionError = (error: any) => {\n        //TODO Handle ERROR\n    }\n\n  //render() function in class components\n  return (\n      // @ts-ignore\n      <gataca-qr\n          callback-server={ verifier ? YOUR_CONNECT_HOST: YOUR_CERTIFY_HOST }\n          ref={qr}\n          qr-role={verifier ? \"connect\":\"certify\"}\n      />\n  )\n\n}\n```\n\n### Angular App Integration\n\nTBD\n\n## Updating from V1\n\nThere are some breaking changes to V2:\n\n- _sessionEndpoint_ and _generationEndpoint_ have been suppressed.\n- _createSession_ and _checkStatus_ functions are now mandatory. The returning parameters of those functions have now changed.\n- _qrRole_ is also mandatory. There is no default value. The possible values have changed to \"**connect**\" and \"**certify**\"\n- _asButton_ and _buttonText_ functionality has been suppressed. That is a different component.\n- _getLoginToken()_ has been suppressed. Any data that wants to be received from the session (from headers, body or whatever) must be provided by the _checkStatus_ result function.\n- _sessionTimeout_ can be removed by introducing a negative value. If removed, the QR will wait until the server provides an error by session expiration.\n\nImprovements:\n\n- Logs have been cleaned\n- Fix providing feedback on the process result and results either if it expires, fails or successes.\n- Stopping the component working upon disappearance\n- Autostart and autorefresh capabilities\n- Documentation and integration with the new provided components\n",
      "docs": "This component built using stencyl allows an easy integration to display a gataca QR to be read by the wallet.\n\nThis component can be used with the prerequisite of having an application which can be integrated with GATACA Components: Connect and Certify. More precisely, your application will need to be able to perform the two operations against your connect or certify servers:\n\n1. Create sessions\n2. Consult sessions",
      "docsTags": [],
      "usage": {},
      "props": [
        {
          "name": "autorefresh",
          "type": "boolean",
          "mutable": false,
          "attr": "autorefresh",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nSet to refresh the session automatically upon expiration. By default it is false",
          "docsTags": [],
          "default": "false",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "autostart",
          "type": "boolean",
          "mutable": false,
          "attr": "autostart",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nSet to enable autoload when the QR is displayed. By default it is true",
          "docsTags": [],
          "default": "true",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "byBrandLabel",
          "type": "string",
          "mutable": false,
          "attr": "by-brand-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"by brand\" label",
          "docsTags": [],
          "default": "\"by Gataca\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "callbackServer",
          "type": "string",
          "mutable": false,
          "attr": "callback-server",
          "reflectToAttr": false,
          "docs": "***Mandatory just for V1***\nConnect/Certify Server where the wallet will send the data",
          "docsTags": [],
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "checkStatus",
          "type": "(id?: string) => Promise<{ result: RESULT_STATUS; data?: any; }>",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "***Mandatory***\nCheck status function to query the current status of the session\nThe function must query a client endpoint to check the status. That endpoint must return an error if the session has expired.",
          "docsTags": [],
          "default": "undefined",
          "values": [
            {
              "type": "(id?: string) => Promise<{ result: RESULT_STATUS; data?: any; }>"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "clickInsideBoxLabel",
          "type": "string",
          "mutable": false,
          "attr": "click-inside-box-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"click inside\" label",
          "docsTags": [],
          "default": "\"Click inside the box to\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "createSession",
          "type": "() => Promise<{ sessionId: string; authenticationRequest?: string; }>",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "***Mandatory***\nCreate session function to generate a new Session\nUsing v=\"3\", it can provide just a session Id\nUsing another version, it must provide also the authentication request. The session Id is the id of the presentation definition",
          "docsTags": [],
          "default": "undefined",
          "values": [
            {
              "type": "() => Promise<{ sessionId: string; authenticationRequest?: string; }>"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "credentialsNotValidatedLabel",
          "type": "string",
          "mutable": false,
          "attr": "credentials-not-validated-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show when credentials not validatedd",
          "docsTags": [],
          "default": "\"User credentials not validated\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "credsNotValidatedErrorLabel",
          "type": "string",
          "mutable": false,
          "attr": "creds-not-validated-error-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"provided credentials not validates\" error",
          "docsTags": [],
          "default": "\"Provided user credentials couldn't be validated\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "dynamicLink",
          "type": "boolean",
          "mutable": false,
          "attr": "dynamic-link",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nDisplay a link containing a dynamic link to invoke the wallet if closed",
          "docsTags": [],
          "default": "true",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "errorCallback",
          "type": "(error?: Error) => void",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "***Mandatory***\nCallback fired upon session expired or invalid\nIf not set, session error would not be handled\nAn error containing information will be passed as parameter",
          "docsTags": [],
          "default": "undefined",
          "values": [
            {
              "type": "(error?: Error) => void"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "failedLoginErrorLabel",
          "type": "string",
          "mutable": false,
          "attr": "failed-login-error-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"failed login\" error",
          "docsTags": [],
          "default": "\"No successful login\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "hideBrandTitle",
          "type": "boolean",
          "mutable": false,
          "attr": "hide-brand-title",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nBoolean to show or not show the gataca brand title",
          "docsTags": [],
          "default": "false",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "hideModalBoxShadow",
          "type": "boolean",
          "mutable": false,
          "attr": "hide-modal-box-shadow",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nBoolean to show or not show the modal title, brandTitle and description",
          "docsTags": [],
          "default": "false",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "hideModalTexts",
          "type": "boolean",
          "mutable": false,
          "attr": "hide-modal-texts",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nBoolean to show or not show the modal title, brandTitle and description",
          "docsTags": [],
          "default": "false",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "hideQrModalDescription",
          "type": "boolean",
          "mutable": false,
          "attr": "hide-qr-modal-description",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nBoolean to show or not show the QR Modal description",
          "docsTags": [],
          "default": "false",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "logoSize",
          "type": "number",
          "mutable": false,
          "attr": "logo-size",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nSize of the logo to display in percentage to the total size [0-1]. 0 means no logo will be displayed. Default is the GATACA logo. Recommended size is around 0.33",
          "docsTags": [],
          "default": "0",
          "values": [
            {
              "type": "number"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "logoSrc",
          "type": "string",
          "mutable": false,
          "attr": "logo-src",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nLogo to display, just if the logo size is greater than 0. No logo is the GATACA logo.",
          "docsTags": [],
          "default": "logoGataca",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "modalHeight",
          "type": "number",
          "mutable": false,
          "attr": "modal-height",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nHeight of the modal",
          "docsTags": [],
          "values": [
            {
              "type": "number"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "modalTitleColor",
          "type": "string",
          "mutable": false,
          "attr": "modal-title-color",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to set Modal title color",
          "docsTags": [],
          "default": "\"#4745B7\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "modalWidth",
          "type": "number",
          "mutable": false,
          "attr": "modal-width",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nWidth of the modal",
          "docsTags": [],
          "default": "300",
          "values": [
            {
              "type": "number"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "pollingFrequency",
          "type": "number",
          "mutable": false,
          "attr": "polling-frequency",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nFrequency in seconds to check if the session has been validated",
          "docsTags": [],
          "default": "DEFAULT_POLLING_FREQ",
          "values": [
            {
              "type": "number"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "qrCodeExpiredLabel",
          "type": "string",
          "mutable": false,
          "attr": "qr-code-expired-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show when qr code expired",
          "docsTags": [],
          "default": "\"QR Code expired\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "qrModalDescription",
          "type": "string",
          "mutable": false,
          "attr": "qr-modal-description",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nModifies the Modal description",
          "docsTags": [],
          "default": "\"Sign up or sign in by scanning the QR Code with the Gataca Wallet\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "qrModalTitle",
          "type": "string",
          "mutable": false,
          "attr": "qr-modal-title",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nModifies the qr headline title",
          "docsTags": [],
          "default": "\"Quick Access\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "qrRole",
          "type": "string",
          "mutable": false,
          "attr": "qr-role",
          "reflectToAttr": false,
          "docs": "***Mandatory just for V1***\nDecide if scanning the credential as a verifier to request credentials\nor as an issuer too issue credentials.\nOptions: connect | certify",
          "docsTags": [],
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "qrSize",
          "type": "number",
          "mutable": false,
          "attr": "qr-size",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nSize of QR Displayed",
          "docsTags": [],
          "default": "300",
          "values": [
            {
              "type": "number"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "readQrDescription",
          "type": "string",
          "mutable": false,
          "attr": "read-qr-description",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString description to show when QR already read",
          "docsTags": [],
          "default": "\"Please wait a moment\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "readQrTitle",
          "type": "string",
          "mutable": false,
          "attr": "read-qr-title",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString title to show when QR already read",
          "docsTags": [],
          "default": "\"Processing...\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "refreshQrLabel",
          "type": "string",
          "mutable": false,
          "attr": "refresh-qr-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"refresh QR\" label",
          "docsTags": [],
          "default": "\"Refresh QR Code\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "scanQrLabel",
          "type": "string",
          "mutable": false,
          "attr": "scan-qr-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"scan QR\" label",
          "docsTags": [],
          "default": "\"Scan QR Code\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "sessionTimeout",
          "type": "number",
          "mutable": false,
          "attr": "session-timeout",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nMaximum time window to display the session",
          "docsTags": [],
          "default": "DEFAULT_SESSION_TIMEOUT",
          "values": [
            {
              "type": "number"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "successCallback",
          "type": "(data?: any) => void",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "***Mandatory***\nCallback fired upon session correctly verified\nIf not set, session validation wouldn't trigger any action\nThe session data and a possible token will be sent as parameters to the callback",
          "docsTags": [],
          "default": "undefined",
          "values": [
            {
              "type": "(data?: any) => void"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "successLoginLabel",
          "type": "string",
          "mutable": false,
          "attr": "success-login-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"successful login\" label",
          "docsTags": [],
          "default": "\"Successful Connection!\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "userNotScanInTimeErrorLabel",
          "type": "string",
          "mutable": false,
          "attr": "user-not-scan-in-time-error-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"user not scan in time\" error",
          "docsTags": [],
          "default": "\"User did not scan the QR in the allowed time\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "v",
          "type": "string",
          "mutable": false,
          "attr": "v",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nIf 3, handle deeplink redirects and deprecates (remove) v1 functionality. If not, the create session must be providing both an authentication request and a session Id",
          "docsTags": [],
          "default": "\"3\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "waitingStartSessionLabel",
          "type": "string",
          "mutable": false,
          "attr": "waiting-start-session-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"waiting start session\" label",
          "docsTags": [],
          "default": "\"waiting to start a session\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        }
      ],
      "methods": [
        {
          "name": "display",
          "returns": {
            "type": "Promise<void>",
            "docs": ""
          },
          "signature": "display() => Promise<void>",
          "parameters": [],
          "docs": "Force manually the display of a QR",
          "docsTags": []
        },
        {
          "name": "getSessionData",
          "returns": {
            "type": "Promise<any>",
            "docs": ""
          },
          "signature": "getSessionData() => Promise<any>",
          "parameters": [],
          "docs": "Retrieve manually the session data on a successful login",
          "docsTags": []
        },
        {
          "name": "stop",
          "returns": {
            "type": "Promise<void>",
            "docs": ""
          },
          "signature": "stop() => Promise<void>",
          "parameters": [],
          "docs": "Stop manually an ongoing session",
          "docsTags": []
        }
      ],
      "events": [
        {
          "event": "gatacaLoginCompleted",
          "detail": "any",
          "bubbles": true,
          "cancelable": true,
          "composed": true,
          "docs": "GatacaLoginCompleted event, triggered with session data upon login success",
          "docsTags": []
        },
        {
          "event": "gatacaLoginFailed",
          "detail": "any",
          "bubbles": true,
          "cancelable": true,
          "composed": true,
          "docs": "GatacaLoginFailed event, triggered with error upon login failure",
          "docsTags": []
        }
      ],
      "listeners": [],
      "styles": [],
      "slots": [],
      "parts": [],
      "dependents": [
        "gataca-autoqr",
        "gataca-ssibutton"
      ],
      "dependencies": [
        "gataca-qrdisplay"
      ],
      "dependencyGraph": {
        "gataca-qr": [
          "gataca-qrdisplay"
        ],
        "gataca-autoqr": [
          "gataca-qr"
        ],
        "gataca-ssibutton": [
          "gataca-qr"
        ]
      }
    },
    {
      "filePath": "./src/components/gataca-qrdisplay/gataca-qrdisplay.tsx",
      "encapsulation": "none",
      "tag": "gataca-qrdisplay",
      "readme": "# Gataca-QR Display\n\nThis component built using stencyl allows an easy integration to display a QR with the gataca styles\n\nContinuing with that example, you could integrate in any HTML using the following code\n\n```html\n<!DOCTYPE html>\n<html dir=\"ltr\" lang=\"en\">\n\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=5.0\">\n  <title>Gataca QR Display Component</title>\n  <script type=\"module\" src=\"/build/gataca-qrdisplay.esm.js\"></script>\n  <script nomodule src=\"/build/gataca-qrdisplay.js\"></script>\n</head>\n\n<body>\n  <div class=\"your-container-styles\">\n\n    <gataca-qrdisplay id=\"gataca-qr\" qr-data=\"DATA TO DISPLAY\">\n      </gataca-qr>\n\n  </div>\n</body>\n\n</html>\n```\n",
      "docs": "This component built using stencyl allows an easy integration to display a QR with the gataca styles\n\nContinuing with that example, you could integrate in any HTML using the following code\n\n```html\n<!DOCTYPE html>\n<html dir=\"ltr\" lang=\"en\">\n\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=5.0\">\n  <title>Gataca QR Display Component</title>\n  <script type=\"module\" src=\"/build/gataca-qrdisplay.esm.js\"></script>\n  <script nomodule src=\"/build/gataca-qrdisplay.js\"></script>\n</head>\n\n<body>\n  <div class=\"your-container-styles\">\n\n    <gataca-qrdisplay id=\"gataca-qr\" qr-data=\"DATA TO DISPLAY\">\n      </gataca-qr>\n\n  </div>\n</body>\n\n</html>\n```",
      "docsTags": [],
      "usage": {},
      "props": [
        {
          "name": "logoSize",
          "type": "number",
          "mutable": false,
          "attr": "logo-size",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nSize of the logo to display in percentage to the total size [0-1]. 0 means no logo will be displayed. Default is the GATACA logo. Recommended size is around 0.33",
          "docsTags": [],
          "default": "0",
          "values": [
            {
              "type": "number"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "logoSrc",
          "type": "string",
          "mutable": false,
          "attr": "logo-src",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nLogo to display, just if the logo size is greater than 0. No logo is the GATACA logo.",
          "docsTags": [],
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "qrColor",
          "type": "string",
          "mutable": false,
          "attr": "qr-color",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nQR Color.",
          "docsTags": [],
          "default": "\"#1E1E20\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "qrData",
          "type": "string",
          "mutable": false,
          "attr": "qr-data",
          "reflectToAttr": false,
          "docs": "_[Mandatory]_\nSets the contents of the QR",
          "docsTags": [],
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "rounded",
          "type": "boolean",
          "mutable": false,
          "attr": "rounded",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nRound usage",
          "docsTags": [],
          "default": "true",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "size",
          "type": "number",
          "mutable": false,
          "attr": "size",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nSize of the QR Displayed",
          "docsTags": [],
          "default": "256",
          "values": [
            {
              "type": "number"
            }
          ],
          "optional": true,
          "required": false
        }
      ],
      "methods": [],
      "events": [],
      "listeners": [],
      "styles": [],
      "slots": [],
      "parts": [],
      "dependents": [
        "gataca-qr",
        "gataca-qrws"
      ],
      "dependencies": [],
      "dependencyGraph": {
        "gataca-qr": [
          "gataca-qrdisplay"
        ],
        "gataca-qrws": [
          "gataca-qrdisplay"
        ]
      }
    },
    {
      "filePath": "./src/components/gataca-qrws/gataca-qrws.tsx",
      "encapsulation": "shadow",
      "tag": "gataca-qrws",
      "readme": "# Gataca-QRWS\n\nThis component built using stencyl allows an easy integration to display a gataca QR to be read by the wallet.\n\nIt does the same but using WebSockets instead of polling\n\nThis component can be used with the prerequisite of having an application which can be integrated with GATACA Components: Connect and Certify. In this case, your application must offer a WebSocket communication.\n\nThe websocket service implemented by your service may be completely custom or use the following structure for messages -the type is exported by this library-:\n\n```typescript\nexport type WSResponse = {\n  sessionId: string;\n  result: RESULT_STATUS;\n  authenticatedUserData?: any;\n  authenticationRequest?: string;\n  error?: string;\n};\n```\n\nIf your WS Messages implement this interface, you need to know that the QR will start when a WS message is received with result === RESULT_STATUS.ONGOING (0) and a sessionId.\nThe QR will end when a message with a different result is received, depending on the result.\n\nIf your server wants to implement a different interface, there is no problem, but you need to trigger an Event named **sessionMsg** with a matching WSResponse in detail for the QR Component to understand (see examples).\n\n\n## Integrations\n\n### Pure JS\n\nYou can include the components by importing the library, available on NPM:\n\n#### Script tag\n\nPut a script tag similar to the source [https://unpkg.com/gatacaqr/dist/gatacaqr.js](https://unpkg.com/gatacaqr/dist/gatacaqr.js) in the head of your index.html. Check for the last version:\n\n```html\n<!DOCTYPE html>\n<html dir=\"ltr\" lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=5.0\">\n  <script src='https://unpkg.com/gatacaqr@2.0.0/dist/gatacaqr.js'></script>\n</head>\n...\n</html>\n```\n\n#### Example\n\n````html\n<!DOCTYPE html>\n<html dir=\"ltr\" lang=\"en\">\n\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=5.0\">\n  <title>Gataca QR Component</title>\n  <script type=\"module\" src=\"/build/gatacaqr.esm.js\"></script>\n  <script nomodule src=\"/build/gatacaqr.js\"></script>\n</head>\n\n<body>\n\n  <div>\n\n    <gataca-qrws id=\"gataca-qrws\" qr-role=\"connect\" session-timeout=\"300\"\n      socket-endpoint=\"ws://your_server\"\n      callback-server=\"https://connect.gataca.io\">  <!-- TODO Change with your connect server and your service socket-->\n    </gataca-qrws>\n\n  </div>\n\n  <script>\n    const qr = document.getElementById('gataca-qrws');\n    var count = 0;\n    var ok = true;\n\n    qr.successCallback = (data) => {\n      //TODO Change with what you want to happen when the session is validated\n      alert(\"ALL OK\" + data)\n    };\n    qr.errorCallback = () => {\n      //TODO Change with what you want to happen when the session is expired or the user provides invalid credentials\n      alert(\"some error\")\n    };\n\n    qr.wsOnOpen = (socket) => {\n      //TODO Use this if you need a client message to start the session request on your API\n      socket.send(\"SESSION_REQUEST\")\n    }\n\n    qr.wsOnMessage = (socket, msg) => {\n      //TODO Change with and invocation to your Backend web socket to query the status of the session\n      let sessionId = \"TWp3V2R1N29ZcmFMY3Nvd3ZPb3k0UlMz\";\n      let wsResponse ={\n        sessionId: sessionId;\n        result: 0;\n      }\n      const event = new CustomEvent('sessionMsg', { detail: wsResponse});\n      qr..dispatchEvent(event);\n      \n      //simulation\n      setTimeout( () => {\n      let wsResponse ={\n        sessionId: sessionId;\n        result: ok? 1:2;\n        error: ok? undefined: \"Invalid user data\"\n      }\n      const event = new CustomEvent('sessionMsg', { detail: wsResponse});\n      qr..dispatchEvent(event);\n      }, 10000)\n        \n    }\n\n  // (async () => {\n  //   await customElements.whenDefined('gataca-qr');\n  // })();\n\n  </script>\n\n</body>\n\n</html>\n````\n\nYou can use this component with an already created session, which can be inserted on the sessionId property on the element, or passed via query parameter _id_ or _sessionId_ on the current URL.\nYou can also provide a method to generate a new session like in the example, or, in the rare event of matching the authorizer API, just the endpoint to your application.\n\nIn order to consult sessions, both options are also available, depending on how you want to develop your own API.\n\n### React App Integration\n\nImport the library\n\n```bash\nnpm install @gataca/qr --save\n```\n\nor\n\n```bash\nyarn add @gataca/qr\n```\n\nIn your base file index.js (or index.tsx), include:\n\n```typescript\nimport { applyPolyfills, defineCustomElements } from '@gataca/qr/loader'\n\n//before ReactDOM.render\napplyPolyfills().then(() => {\n    defineCustomElements(window)\n})\n\n```\n\nThe integration would depend if your using a Class Component or a Function Component. Supposing a function component (adaptation to class components is trivial), you would need to include:\n\n````typescript\ntype MyProps = {\n    ...\n    verifier?: boolean\n}\n\n\nexport const dummyComponent: React.FC<MyProps> = (props) => {\n  ...\n  const { verifier } = props\n  const qr = useRef(null)\n  let gqr: HTMLGatacaQrElement | undefined\n\n  useEffect(() => {\n            if (qr != null && qr.current != null) {\n                gqr = qr.current! as HTMLGatacaQrElement\n                gqr.wsOnOpen = requestSession //Optional\n                gqr.wsOnMessage = receiveMessage\n                gqr.successCallback = createSessionSuccess\n                gqr.errorCallback = createSessionError\n        }\n    })\n\n\n    //TODO Implement your own service logic invocation. This is just a dummy. Change with and invocation to your Backend websocket to query the status of the session\n     const receiveMessage = async (msg: MessageEvent): => {\n      let wsResponse = convertMyAPIMessageToWSResponse(msg)\n      const event = new CustomEvent('sessionMsg', { detail: wsResponse});\n      qr..dispatchEvent(event);        \n    }\n\n    //TODO fix with your API Data\n    const convertMyAPIMessageToWSResponse = (msg: MessageEvent) :WSResponse => {\n      //Example: session created\n      //TODO Process Message and transform to WSResponse object\n      return {\n          sessionId: 'somesession';\n          result: RESULT_STATUS.ONGOING;\n        };\n    }\n\n      //TODO Use this if you need a client message to start the session request on your API\n    const requestSession = (socket) => {\n      socket.send(\"SESSION_REQUEST\")\n    }\n\n    const createSessionSuccess = (newdata: any) => {\n        //TODO Handle success\n    }\n\n    const createSessionError = (error: any) => {\n        //TODO Handle ERROR\n    }\n\n  //render() function in class components\n  return (\n      // @ts-ignore\n      <gataca-qrws\n          callback-server={ verifier ? YOUR_CONNECT_HOST: YOUR_CERTIFY_HOST }\n          socket-endpoint={YOUR_SERVICE}\n          ref={qr}\n          qr-role={verifier ? \"connect\":\"certify\"}\n      />\n    )\n}\n````\n\n### Angular App Integration\n\nTBD\n\n",
      "docs": "This component built using stencyl allows an easy integration to display a gataca QR to be read by the wallet.\n\nIt does the same but using WebSockets instead of polling\n\nThis component can be used with the prerequisite of having an application which can be integrated with GATACA Components: Connect and Certify. In this case, your application must offer a WebSocket communication.\n\nThe websocket service implemented by your service may be completely custom or use the following structure for messages -the type is exported by this library-:\n\n```typescript\nexport type WSResponse = {\n  sessionId: string;\n  result: RESULT_STATUS;\n  authenticatedUserData?: any;\n  authenticationRequest?: string;\n  error?: string;\n};\n```\n\nIf your WS Messages implement this interface, you need to know that the QR will start when a WS message is received with result === RESULT_STATUS.ONGOING (0) and a sessionId.\nThe QR will end when a message with a different result is received, depending on the result.\n\nIf your server wants to implement a different interface, there is no problem, but you need to trigger an Event named **sessionMsg** with a matching WSResponse in detail for the QR Component to understand (see examples).",
      "docsTags": [],
      "usage": {},
      "props": [
        {
          "name": "autorefresh",
          "type": "boolean",
          "mutable": false,
          "attr": "autorefresh",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nSet to refresh the session automatically upon expiration. By default it is false",
          "docsTags": [],
          "default": "false",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "autostart",
          "type": "boolean",
          "mutable": false,
          "attr": "autostart",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nSet to enable autoload when the QR is displayed. By default it is true",
          "docsTags": [],
          "default": "true",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "byBrandLabel",
          "type": "string",
          "mutable": false,
          "attr": "by-brand-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"by brand\" label",
          "docsTags": [],
          "default": "\"by Gataca\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "callbackServer",
          "type": "string",
          "mutable": false,
          "attr": "callback-server",
          "reflectToAttr": false,
          "docs": "***Mandatory just for V1***\nConnect/Certify Server where the wallet will send the data",
          "docsTags": [],
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "clickInsideBoxLabel",
          "type": "string",
          "mutable": false,
          "attr": "click-inside-box-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"click inside\" label",
          "docsTags": [],
          "default": "\"Click inside the box to\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "credentialsNotValidatedLabel",
          "type": "string",
          "mutable": false,
          "attr": "credentials-not-validated-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show when credentials not validatedd",
          "docsTags": [],
          "default": "\"User credentials not validated\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "credsNotValidatedErrorLabel",
          "type": "string",
          "mutable": false,
          "attr": "creds-not-validated-error-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"provided credentials not validates\" error",
          "docsTags": [],
          "default": "\"Provided user credentials couldn't be validated\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "dynamicLink",
          "type": "boolean",
          "mutable": false,
          "attr": "dynamic-link",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nDisplay a link containing a dynamic link to invoke the wallet if closed",
          "docsTags": [],
          "default": "true",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "errorCallback",
          "type": "(error?: Error) => void",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "***Mandatory***\nCallback fired upon session expired or invalid\nIf not set, session error would not be handled\nAn error containing information will be passed as parameter",
          "docsTags": [],
          "default": "undefined",
          "values": [
            {
              "type": "(error?: Error) => void"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "failedLoginErrorLabel",
          "type": "string",
          "mutable": false,
          "attr": "failed-login-error-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"failed login\" error",
          "docsTags": [],
          "default": "\"No successful login\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "hideBrandTitle",
          "type": "boolean",
          "mutable": false,
          "attr": "hide-brand-title",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nBoolean to show or not show the gataca brand title",
          "docsTags": [],
          "default": "false",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "hideModalBoxShadow",
          "type": "boolean",
          "mutable": false,
          "attr": "hide-modal-box-shadow",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nBoolean to show or not show the modal title, brandTitle and description",
          "docsTags": [],
          "default": "false",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "hideModalTexts",
          "type": "boolean",
          "mutable": false,
          "attr": "hide-modal-texts",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nBoolean to show or not show the modal title, brandTitle and description",
          "docsTags": [],
          "default": "false",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "hideQrModalDescription",
          "type": "boolean",
          "mutable": false,
          "attr": "hide-qr-modal-description",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nBoolean to show or not show the QR Modal description",
          "docsTags": [],
          "default": "false",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "logoSize",
          "type": "number",
          "mutable": false,
          "attr": "logo-size",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nSize of the logo to display in percentage to the total size [0-1]. 0 means no logo will be displayed. Default is the GATACA logo. Recommended size is around 0.33",
          "docsTags": [],
          "default": "0",
          "values": [
            {
              "type": "number"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "logoSrc",
          "type": "string",
          "mutable": false,
          "attr": "logo-src",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nLogo to display, just if the logo size is greater than 0. No logo is the GATACA logo.",
          "docsTags": [],
          "default": "logoGataca",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "modalHeight",
          "type": "number",
          "mutable": false,
          "attr": "modal-height",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nHeight of the modal",
          "docsTags": [],
          "values": [
            {
              "type": "number"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "modalTitleColor",
          "type": "string",
          "mutable": false,
          "attr": "modal-title-color",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to set Modal title color",
          "docsTags": [],
          "default": "\"#4745B7\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "modalWidth",
          "type": "number",
          "mutable": false,
          "attr": "modal-width",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nWidth of the modal",
          "docsTags": [],
          "default": "300",
          "values": [
            {
              "type": "number"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "qrCodeExpiredLabel",
          "type": "string",
          "mutable": false,
          "attr": "qr-code-expired-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show when qr code expired",
          "docsTags": [],
          "default": "\"QR Code expired\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "qrModalDescription",
          "type": "string",
          "mutable": false,
          "attr": "qr-modal-description",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nModifies the Modal description",
          "docsTags": [],
          "default": "\"Sign up or sign in by scanning the QR Code with the Gataca Wallet\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "qrModalTitle",
          "type": "string",
          "mutable": false,
          "attr": "qr-modal-title",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nModifies the qr headline title",
          "docsTags": [],
          "default": "\"Quick Access\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "qrRole",
          "type": "string",
          "mutable": false,
          "attr": "qr-role",
          "reflectToAttr": false,
          "docs": "***Mandatory***\nDecide if scanning the credential as a verifier to request credentials\nor as an issuer too issue credentials.\nOptions: connect | certify",
          "docsTags": [],
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "qrSize",
          "type": "number",
          "mutable": false,
          "attr": "qr-size",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nSize of QR Displayed",
          "docsTags": [],
          "default": "300",
          "values": [
            {
              "type": "number"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "readQrDescription",
          "type": "string",
          "mutable": false,
          "attr": "read-qr-description",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString description to show when QR already read",
          "docsTags": [],
          "default": "\"Please wait a moment\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "readQrTitle",
          "type": "string",
          "mutable": false,
          "attr": "read-qr-title",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString title to show when QR already read",
          "docsTags": [],
          "default": "\"Processing...\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "refreshQrLabel",
          "type": "string",
          "mutable": false,
          "attr": "refresh-qr-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"refresh QR\" label",
          "docsTags": [],
          "default": "\"Refresh QR Code\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "scanQrLabel",
          "type": "string",
          "mutable": false,
          "attr": "scan-qr-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"scan QR\" label",
          "docsTags": [],
          "default": "\"Scan QR Code\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "sessionTimeout",
          "type": "number",
          "mutable": false,
          "attr": "session-timeout",
          "reflectToAttr": false,
          "docs": "***Mandatory***\nMaximum time window to display the session and keep the websocket connection. It's needed to ensure the socket is closed.",
          "docsTags": [],
          "default": "DEFAULT_SESSION_TIMEOUT",
          "values": [
            {
              "type": "number"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "socketEndpoint",
          "type": "string",
          "mutable": false,
          "attr": "socket-endpoint",
          "reflectToAttr": false,
          "docs": "***Mandatory***\nWS Endpoint on your service to be invoked upon display",
          "docsTags": [],
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "successCallback",
          "type": "(data?: any) => void",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "***Mandatory***\nCallback fired upon session correctly verified\nIf not set, session validation wouldn't trigger any action\nThe session data and a possible token will be sent as parameters to the callback",
          "docsTags": [],
          "default": "undefined",
          "values": [
            {
              "type": "(data?: any) => void"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "successLoginLabel",
          "type": "string",
          "mutable": false,
          "attr": "success-login-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"successful login\" label",
          "docsTags": [],
          "default": "\"Successful Connection!\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "userNotScanInTimeErrorLabel",
          "type": "string",
          "mutable": false,
          "attr": "user-not-scan-in-time-error-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"user not scan in time\" error",
          "docsTags": [],
          "default": "\"User did not scan the QR in the allowed time\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "v",
          "type": "string",
          "mutable": false,
          "attr": "v",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nIf 3, handle deeplink redirects and deprecates (remove) v1 functionality. If not, the create session must be providing both an authentication request and a session Id",
          "docsTags": [],
          "default": "\"3\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "waitingStartSessionLabel",
          "type": "string",
          "mutable": false,
          "attr": "waiting-start-session-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"waiting start session\" label",
          "docsTags": [],
          "default": "\"waiting to start a session\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "wsOnMessage",
          "type": "(socket: WebSocket, msg: MessageEvent<any>) => void",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "**RECOMMENDED**\nCallback to invoke an a message has been received on the socket. It provides the socket itself and the message as parameters.\nIf not used, the messages provided by the server on the Socket connection must conform to the WSReponse interface\nIf used, an Event named **sessionMsg** must be triggered with a WSReponse as data",
          "docsTags": [],
          "values": [
            {
              "type": "(socket: WebSocket, msg: MessageEvent<any>) => void"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "wsOnOpen",
          "type": "(socket: WebSocket) => void",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "[Optional]\nFunction to send a message to the server upon socket creation",
          "docsTags": [],
          "values": [
            {
              "type": "(socket: WebSocket) => void"
            }
          ],
          "optional": false,
          "required": false
        }
      ],
      "methods": [
        {
          "name": "display",
          "returns": {
            "type": "Promise<void>",
            "docs": ""
          },
          "signature": "display() => Promise<void>",
          "parameters": [],
          "docs": "Force manually the display of a QR",
          "docsTags": []
        },
        {
          "name": "getSessionData",
          "returns": {
            "type": "Promise<any>",
            "docs": ""
          },
          "signature": "getSessionData() => Promise<any>",
          "parameters": [],
          "docs": "Retrieve manually the session data on a successful login",
          "docsTags": []
        },
        {
          "name": "stop",
          "returns": {
            "type": "Promise<void>",
            "docs": ""
          },
          "signature": "stop() => Promise<void>",
          "parameters": [],
          "docs": "Stop manually an ongoing session",
          "docsTags": []
        }
      ],
      "events": [
        {
          "event": "gatacaLoginCompleted",
          "detail": "any",
          "bubbles": true,
          "cancelable": true,
          "composed": true,
          "docs": "GatacaLoginCompleted event, triggered with session data upon login success",
          "docsTags": []
        },
        {
          "event": "gatacaLoginFailed",
          "detail": "any",
          "bubbles": true,
          "cancelable": true,
          "composed": true,
          "docs": "GatacaLoginFailed event, triggered with error upon login failure",
          "docsTags": []
        }
      ],
      "listeners": [
        {
          "event": "sessionMsg",
          "capture": true,
          "passive": false
        }
      ],
      "styles": [],
      "slots": [],
      "parts": [],
      "dependents": [
        "gataca-autoqr",
        "gataca-ssibuttonws"
      ],
      "dependencies": [
        "gataca-qrdisplay"
      ],
      "dependencyGraph": {
        "gataca-qrws": [
          "gataca-qrdisplay"
        ],
        "gataca-autoqr": [
          "gataca-qrws"
        ],
        "gataca-ssibuttonws": [
          "gataca-qrws"
        ]
      }
    },
    {
      "filePath": "./src/components/gataca-ssibutton/gataca-ssibutton.tsx",
      "encapsulation": "shadow",
      "tag": "gataca-ssibutton",
      "readme": "# Gataca-SSIButton\n\nThis component built using stencyl allows an easy integration to display a \"Quick SSI Access Button\", with a similar to the current existing sign-in buttons for OAuth2 providers like Google, Twitter or Facebook.\n\nThis component wraps the logic to display and hide a Gataca-QR component under a button. To configure and integrate it, you need to follow the same process as the basic [Gataca-QR component](../gataca-qr/readme.md).\n\nThis component can be used with the prerequisite of having an application which can be integrated with GATACA Components: Connect and Certify. More precisely, your application will need to be able to perform the two operations against your connect or certify servers:\n\n1. Create sessions\n2. Consult sessions\n\n## Integrations\n\n### Pure JS\n\nYou can include the components by importing the library, available on NPM:\n\n#### Script tag\n\nPut a script tag similar to the source [https://unpkg.com/gatacaqr/dist/gatacaqr.js](https://unpkg.com/gatacaqr/dist/gatacaqr.js) in the head of your index.html. Check for the last version:\n\n```html\n<!DOCTYPE html>\n<html dir=\"ltr\" lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=5.0\"\n    />\n    <script src=\"https://unpkg.com/gatacaqr@2.0.0/dist/gatacaqr.js\"></script>\n  </head>\n  ...\n</html>\n```\n\n#### Example\n\n```html\n<!DOCTYPE html>\n<html dir=\"ltr\" lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=5.0\"\n    />\n    <title>Gataca SSI Button</title>\n    <script type=\"module\" src=\"/build/gatacaqr.esm.js\"></script>\n    <script nomodule src=\"/build/gatacaqr.js\"></script>\n  </head>\n  <body>\n    <div>\n      <gataca-ssibutton\n        id=\"gataca-qr\"\n        qrRole=\"connect\"\n        callback-server=\"https://connect.gataca.io\"\n      >\n        <!-- TODO Change with your connect server-->\n      </gataca-ssibutton>\n    </div>\n\n    <script>\n      const qr = document.getElementById(\"gataca-qr\");\n      var count = 0;\n      var ok = true;\n\n      qr.successCallback = (data) => {\n        //TODO Change with what you want to happen when the session is validated\n        alert(\"ALL OK\" + data);\n      };\n      qr.errorCallback = () => {\n        //TODO Change with what you want to happen when the session is expired or the user provides invalid credentials\n        alert(\"some error\");\n      };\n\n      qr.createSession = () => {\n        // Authentication request is required\n        return {\n          sessionId: \"TWp3V2R1N29ZcmFMY3Nvd3ZPb3k0UlMz\",\n          authenticationRequest: \"\",\n        };\n      };\n\n      qr.checkStatus = () => {\n        //TODO Change with and invocation to your Backend service to query the status of the session\n        count++;\n        if (count == 10) {\n          return { result: ok ? 1 : 2, data: { name: \"test\", token: \"x\" } };\n        }\n        return { result: 0 };\n      };\n    </script>\n  </body>\n</html>\n```\n\nYou can use this component with an already created session, which can be inserted on the sessionId property on the element, or passed via query parameter _id_ or _sessionId_ on the current URL.\nYou can also provide a method to generate a new session like in the example, or, in the rare event of matching the authorizer API, just the endpoint to your application.\n\nIn order to consult sessions, both options are also available, depending on how you want to develop your own API.\n\n### React App Integration\n\nImport the library\n\n```bash\nnpm install @gataca/qr --save\n```\n\nor\n\n```bash\nyarn add @gataca/qr\n```\n\nIn your base file index.js (or index.tsx), include:\n\n```typescript\nimport { applyPolyfills, defineCustomElements } from \"@gataca/qr/loader\";\n\n//before ReactDOM.render\napplyPolyfills().then(() => {\n  defineCustomElements(window);\n});\n```\n\nThe integration would depend if your using a Class Component or a Function Component. Supposing a function component (adaptation to class components is trivial), you would need to include:\n\n```typescript\ntype MyProps = {\n    ...\n    verifier?: boolean\n    configId?: string\n    appToken?: string\n}\n\n\nexport const dummyComponent: React.FC<MyProps> = (props) => {\n  ...\n  const { verifier, appToken, configId } = props\n  const qr = useRef(null)\n  let gqr: HTMLGatacaQrElement | undefined\n\n  useEffect(() => {\n            if (qr != null && qr.current != null) {\n                gqr = qr.current! as HTMLGatacaQrElement\n                gqr.createSession = createSession\n                gqr.checkStatus = checkStatus\n                gqr.successCallback = createSessionSuccess\n                gqr.errorCallback = createSessionError\n        }\n    })\n\n\n    //TODO Implement your own service logic invocation. This is just a dummy mimicking the Connect/Certify v1 APIs asuming you get an app token in props\n     const createSession = async (): Promise<{\n        sessionId: string\n        authenticationRequest?: string\n    }> => {\n        try {\n            let endpoint =\n                server +\n                (verifier ? '/api/v1/sessions' : '/api/v1/issuanceRequests')\n            let response = await fetch(endpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    Authorization: 'jwt ' + appToken,\n                },\n                body: verifier\n                    ? '{\"ssiConfigId\": \"' + configId + '\"}'\n                    : '{\"group\": \"' + configId + '\"}',\n            })\n            let data = await response.json()\n            return { sessionId: data.id! }\n        } catch (error) {\n            setSessionErrorState(true)\n            throw error\n        }\n    }\n\n    const checkStatus = async (): Promise<{\n        result: RESULT_STATUS\n        data?: any\n    }> => {\n        //TODO Implement your own service logic invocation. This is just a dummy mimicking the Connect/Certify v1 APIs asuming you get an app token in props\n        if (!appToken || error) {\n            gqr?.stop()\n        }\n        const endpoint =\n            server +\n            (verifier ? '/api/v1/sessions/' : '/admin/v1/issuanceRequests/') +\n            sessionId\n        let response = await fetch(endpoint, {\n            method: 'GET',\n            headers: {\n                Authorization: 'jwt ' + appToken,\n                'Content-Type': 'application/json',\n            },\n        })\n\n        if (verifier) {\n            let req = await response\n            return req.status === 200\n                ? { result: RESULT_STATUS.SUCCESS }\n                : req.status === 204\n                ? { result: RESULT_STATUS.ONGOING }\n                : { result: RESULT_STATUS.FAILED }\n        } else {\n            let req = await response.json()\n            return !req.status || req.status === 'PENDING'\n                ? { result: RESULT_STATUS.ONGOING }\n                : req.status === 'INVALID'\n                ? { result: RESULT_STATUS.FAILED }\n                : { result: RESULT_STATUS.SUCCESS }\n        }\n    }\n\n    const createSessionSuccess = (newdata: any) => {\n        //TODO Handle success\n    }\n\n    const createSessionError = (error: any) => {\n        //TODO Handle ERROR\n    }\n\n  //render() function in class components\n  return (\n      // @ts-ignore\n      <gataca-ssibutton\n          callback-server={ verifier ? YOUR_CONNECT_HOST: YOUR_CERTIFY_HOST }\n          ref={qr}\n          qr-role={verifier ? \"connect\":\"certify\"}\n      />\n  )\n\n}\n```\n\n### Angular App Integration\n\nTBD\n",
      "docs": "This component built using stencyl allows an easy integration to display a \"Quick SSI Access Button\", with a similar to the current existing sign-in buttons for OAuth2 providers like Google, Twitter or Facebook.\n\nThis component wraps the logic to display and hide a Gataca-QR component under a button. To configure and integrate it, you need to follow the same process as the basic [Gataca-QR component](../gataca-qr/readme.md).\n\nThis component can be used with the prerequisite of having an application which can be integrated with GATACA Components: Connect and Certify. More precisely, your application will need to be able to perform the two operations against your connect or certify servers:\n\n1. Create sessions\n2. Consult sessions",
      "docsTags": [],
      "usage": {},
      "props": [
        {
          "name": "autorefresh",
          "type": "boolean",
          "mutable": false,
          "attr": "autorefresh",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nSet to refresh the session automatically upon expiration. By default it is false",
          "docsTags": [],
          "default": "false",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "buttonText",
          "type": "string",
          "mutable": false,
          "attr": "button-text",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nIn the case of being a button, modifies its text",
          "docsTags": [],
          "default": "\"Easy login\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "byBrandLabel",
          "type": "string",
          "mutable": false,
          "attr": "by-brand-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"by brand\" label",
          "docsTags": [],
          "default": "\"by Gataca\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "callbackServer",
          "type": "string",
          "mutable": false,
          "attr": "callback-server",
          "reflectToAttr": false,
          "docs": "***Mandatory just for V1***\nConnect/Certify Server where the wallet will send the data",
          "docsTags": [],
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "checkStatus",
          "type": "(id?: string) => Promise<{ result: RESULT_STATUS; data?: any; }>",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "***Mandatory***\nCheck status function to query the current status of the session\nThe function must query a client endpoint to check the status. That endpoint must return an error if the session has expired.",
          "docsTags": [],
          "default": "undefined",
          "values": [
            {
              "type": "(id?: string) => Promise<{ result: RESULT_STATUS; data?: any; }>"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "clickInsideBoxLabel",
          "type": "string",
          "mutable": false,
          "attr": "click-inside-box-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"click inside\" label",
          "docsTags": [],
          "default": "\"Click inside the box to\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "createSession",
          "type": "() => Promise<{ sessionId: string; authenticationRequest?: string; }>",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "***Mandatory***\nCreate session function to generate a new Session\nUsing v=\"3\", it can provide just a session Id\nUsing another version, it must provide also the authentication request. The session Id is the id of the presentation definition",
          "docsTags": [],
          "default": "undefined",
          "values": [
            {
              "type": "() => Promise<{ sessionId: string; authenticationRequest?: string; }>"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "credentialsNotValidatedLabel",
          "type": "string",
          "mutable": false,
          "attr": "credentials-not-validated-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show when credentials not validatedd",
          "docsTags": [],
          "default": "\"User credentials not validated\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "credsNotValidatedErrorLabel",
          "type": "string",
          "mutable": false,
          "attr": "creds-not-validated-error-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"provided credentials not validates\" error",
          "docsTags": [],
          "default": "\"Provided user credentials couldn't be validated\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "dynamicLink",
          "type": "boolean",
          "mutable": false,
          "attr": "dynamic-link",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nDisplay a link containing a dynamic link to invoke the wallet if closed",
          "docsTags": [],
          "default": "true",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "errorCallback",
          "type": "(error?: Error) => void",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "***Mandatory***\nCallback fired upon session expired or invalid\nIf not set, session error would not be handled\nAn error containing information will be passed as parameter",
          "docsTags": [],
          "default": "undefined",
          "values": [
            {
              "type": "(error?: Error) => void"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "failedLoginErrorLabel",
          "type": "string",
          "mutable": false,
          "attr": "failed-login-error-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"failed login\" error",
          "docsTags": [],
          "default": "\"No successful login\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "hideBrandTitle",
          "type": "boolean",
          "mutable": false,
          "attr": "hide-brand-title",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nBoolean to show or not show the gataca brand title",
          "docsTags": [],
          "default": "false",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "hideQrModalDescription",
          "type": "boolean",
          "mutable": false,
          "attr": "hide-qr-modal-description",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nBoolean to show or not show the QR Modal description",
          "docsTags": [],
          "default": "false",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "logoSize",
          "type": "number",
          "mutable": false,
          "attr": "logo-size",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nSize of the logo to display in percentage to the total size [0-1]. 0 means no logo will be displayed. Default is the GATACA logo. Recommended size is around 0.33",
          "docsTags": [],
          "default": "0",
          "values": [
            {
              "type": "number"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "logoSrc",
          "type": "string",
          "mutable": false,
          "attr": "logo-src",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nLogo to display, just if the logo size is greater than 0. No logo is the GATACA logo.",
          "docsTags": [],
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "modalTitleColor",
          "type": "string",
          "mutable": false,
          "attr": "modal-title-color",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to set Modal title color",
          "docsTags": [],
          "default": "\"#4745B7\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "pollingFrequency",
          "type": "number",
          "mutable": false,
          "attr": "polling-frequency",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nFrequency in seconds to check if the session has been validated",
          "docsTags": [],
          "values": [
            {
              "type": "number"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "qrCodeExpiredLabel",
          "type": "string",
          "mutable": false,
          "attr": "qr-code-expired-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show when qr code expired",
          "docsTags": [],
          "default": "\"QR Code expired\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "qrModalDescription",
          "type": "string",
          "mutable": false,
          "attr": "qr-modal-description",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nModifies the Modal description",
          "docsTags": [],
          "default": "\"Sign up or sign in by scanning the QR Code with the Gataca Wallet\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "qrModalTitle",
          "type": "string",
          "mutable": false,
          "attr": "qr-modal-title",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nModifies the qr headline title",
          "docsTags": [],
          "default": "\"Quick Access\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "qrRole",
          "type": "string",
          "mutable": false,
          "attr": "qr-role",
          "reflectToAttr": false,
          "docs": "***Mandatory***\nDecide if scanning the credential as a verifier to request credentials\nor as an issuer too issue credentials.\nOptions: connect | certify",
          "docsTags": [],
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "refreshQrLabel",
          "type": "string",
          "mutable": false,
          "attr": "refresh-qr-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"refresh QR\" label",
          "docsTags": [],
          "default": "\"Refresh QR Code\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "scanQrLabel",
          "type": "string",
          "mutable": false,
          "attr": "scan-qr-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"scan QR\" label",
          "docsTags": [],
          "default": "\"Scan QR Code\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "sessionTimeout",
          "type": "number",
          "mutable": false,
          "attr": "session-timeout",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nMaximum time window to display the session",
          "docsTags": [],
          "values": [
            {
              "type": "number"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "successCallback",
          "type": "(data?: any) => void",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "***Mandatory***\nCallback fired upon session correctly verified\nIf not set, session validation wouldn't trigger any action\nThe session data and a possible token will be sent as parameters to the callback",
          "docsTags": [],
          "default": "undefined",
          "values": [
            {
              "type": "(data?: any) => void"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "successLoginLabel",
          "type": "string",
          "mutable": false,
          "attr": "success-login-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"successful login\" label",
          "docsTags": [],
          "default": "\"Successful Connection!\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "userNotScanInTimeErrorLabel",
          "type": "string",
          "mutable": false,
          "attr": "user-not-scan-in-time-error-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"user not scan in time\" error",
          "docsTags": [],
          "default": "\"User did not scan the QR in the allowed time\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "v",
          "type": "string",
          "mutable": false,
          "attr": "v",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nIf 3, handle deeplink redirects and deprecates (remove) v1 functionality. If not, the create session must be providing both an authentication request and a session Id",
          "docsTags": [],
          "default": "\"3\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "waitingStartSessionLabel",
          "type": "string",
          "mutable": false,
          "attr": "waiting-start-session-label",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nString to show \"waiting start session\" label",
          "docsTags": [],
          "default": "\"waiting to start a session\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        }
      ],
      "methods": [
        {
          "name": "getSessionData",
          "returns": {
            "type": "Promise<any>",
            "docs": ""
          },
          "signature": "getSessionData() => Promise<any>",
          "parameters": [],
          "docs": "Retrieve manually the session data on a successful login",
          "docsTags": []
        }
      ],
      "events": [
        {
          "event": "gatacaLoginCompleted",
          "detail": "any",
          "bubbles": true,
          "cancelable": true,
          "composed": true,
          "docs": "GatacaLoginCompleted event, triggered with session data upon login success",
          "docsTags": []
        },
        {
          "event": "gatacaLoginFailed",
          "detail": "any",
          "bubbles": true,
          "cancelable": true,
          "composed": true,
          "docs": "GatacaLoginFailed event, triggered with error upon login failure",
          "docsTags": []
        }
      ],
      "listeners": [],
      "styles": [],
      "slots": [],
      "parts": [],
      "dependents": [
        "gataca-autoqr"
      ],
      "dependencies": [
        "gataca-qr"
      ],
      "dependencyGraph": {
        "gataca-ssibutton": [
          "gataca-qr"
        ],
        "gataca-qr": [
          "gataca-qrdisplay"
        ],
        "gataca-autoqr": [
          "gataca-ssibutton"
        ]
      }
    },
    {
      "filePath": "./src/components/gataca-ssibuttonws/gataca-ssibuttonws.tsx",
      "encapsulation": "shadow",
      "tag": "gataca-ssibuttonws",
      "readme": "# Gataca-SSIButtonWS\n\nThis component built using stencyl allows an easy integration to display a \"Quick SSI Access Button\", with a similar to the current existing sign-in buttons for OAuth2 providers like Google, Twitter or Facebook. The display is identical to the simple [Gataca-SSI Button](../gataca-ssibutton/readme.md), but with a component using websockets underneath.\n\nThis component wraps the logic to display and hide a Gataca-QR component under a button. To configure and integrate it, you need to follow the same process as the base [Gataca-QRWS Component](../gataca-qrws/readme.md). It is the suitable option if you wish to display an SSI Button but allowing the use of WebSockets instead of polling.\n\nThis component can be used with the prerequisite of having an application which can be integrated with GATACA Components: Connect and Certify. In this case, your application must offer a WebSocket communication.\n\nThe websocket service implemented by your service may be completely custom or use the following structure for messages -the type is exported by this library-:\n\n```typescript\nexport type WSResponse = {\n  sessionId: string;\n  result: RESULT_STATUS;\n  authenticatedUserData?: any;\n  authenticationRequest?: string;\n  error?: string;\n};\n```\n\nIf your WS Messages implement this interface, you need to know that the QR will start when a WS message is received with result === RESULT_STATUS.ONGOING (0) and a sessionId.\nThe QR will end when a message with a different result is received, depending on the result.\n\nIf your server wants to implement a different interface, there is no problem, but you need to trigger an Event named **sessionMsg** with a matching WSResponse in detail for the QR Component to understand (see examples).\n\n## Integrations\n\n### Pure JS\n\nYou can include the components by importing the library, available on NPM:\n\n#### Script tag\n\nPut a script tag similar to the source [https://unpkg.com/gatacaqr/dist/gatacaqr.js](https://unpkg.com/gatacaqr/dist/gatacaqr.js) in the head of your index.html. Check for the last version:\n\n```html\n<!DOCTYPE html>\n<html dir=\"ltr\" lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=5.0\">\n  <script src='https://unpkg.com/gatacaqr@2.0.0/dist/gatacaqr.js'></script>\n</head>\n...\n</html>\n```\n\n#### Example\n\n````html\n<!DOCTYPE html>\n<html dir=\"ltr\" lang=\"en\">\n\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=5.0\">\n  <title>Gataca QR Component</title>\n  <script type=\"module\" src=\"/build/gatacaqr.esm.js\"></script>\n  <script nomodule src=\"/build/gatacaqr.js\"></script>\n</head>\n\n<body>\n\n  <div>\n\n    <gataca-qrws id=\"gataca-qrws\" qr-role=\"connect\" session-timeout=\"300\"\n      socket-endpoint=\"ws://your_server\"\n      callback-server=\"https://connect.gataca.io\">  <!-- TODO Change with your connect server and your service socket-->\n    </gataca-qrws>\n\n  </div>\n\n  <script>\n    const qr = document.getElementById('gataca-qrws');\n    var count = 0;\n    var ok = true;\n\n    qr.successCallback = (data) => {\n      //TODO Change with what you want to happen when the session is validated\n      alert(\"ALL OK\" + data)\n    };\n    qr.errorCallback = () => {\n      //TODO Change with what you want to happen when the session is expired or the user provides invalid credentials\n      alert(\"some error\")\n    };\n\n    qr.wsOnOpen = (socket) => {\n      //TODO Use this if you need a client message to start the session request on your API\n      socket.send(\"SESSION_REQUEST\")\n    }\n\n    qr.wsOnMessage = (socket, msg) => {\n      //TODO Change with and invocation to your Backend web socket to query the status of the session\n      let sessionId = \"TWp3V2R1N29ZcmFMY3Nvd3ZPb3k0UlMz\";\n      let wsResponse ={\n        sessionId: sessionId;\n        result: 0;\n      }\n      const event = new CustomEvent('sessionMsg', { detail: wsResponse});\n      qr..dispatchEvent(event);\n      \n      //simulation\n      setTimeout( () => {\n      let wsResponse ={\n        sessionId: sessionId;\n        result: ok? 1:2;\n        error: ok? undefined: \"Invalid user data\"\n      }\n      const event = new CustomEvent('sessionMsg', { detail: wsResponse});\n      qr..dispatchEvent(event);\n      }, 10000)\n        \n    }\n\n  // (async () => {\n  //   await customElements.whenDefined('gataca-qr');\n  // })();\n\n  </script>\n\n</body>\n\n</html>\n````\n\nYou can use this component with an already created session, which can be inserted on the sessionId property on the element, or passed via query parameter _id_ or _sessionId_ on the current URL.\nYou can also provide a method to generate a new session like in the example, or, in the rare event of matching the authorizer API, just the endpoint to your application.\n\nIn order to consult sessions, both options are also available, depending on how you want to develop your own API.\n\n### React App Integration\n\nImport the library\n\n```bash\nnpm install @gataca/qr --save\n```\n\nor\n\n```bash\nyarn add @gataca/qr\n```\n\nIn your base file index.js (or index.tsx), include:\n\n```typescript\nimport { applyPolyfills, defineCustomElements } from '@gataca/qr/loader'\n\n//before ReactDOM.render\napplyPolyfills().then(() => {\n    defineCustomElements(window)\n})\n\n```\n\nThe integration would depend if your using a Class Component or a Function Component. Supposing a function component (adaptation to class components is trivial), you would need to include:\n\n````typescript\ntype MyProps = {\n    ...\n    verifier?: boolean\n}\n\n\nexport const dummyComponent: React.FC<MyProps> = (props) => {\n  ...\n  const { verifier } = props\n  const qr = useRef(null)\n  let gqr: HTMLGatacaQrElement | undefined\n\n  useEffect(() => {\n            if (qr != null && qr.current != null) {\n                gqr = qr.current! as HTMLGatacaQrElement\n                gqr.wsOnOpen = requestSession //Optional\n                gqr.wsOnMessage = receiveMessage\n                gqr.successCallback = createSessionSuccess\n                gqr.errorCallback = createSessionError\n        }\n    })\n\n\n    //TODO Implement your own service logic invocation. This is just a dummy. Change with and invocation to your Backend websocket to query the status of the session\n     const receiveMessage = async (msg: MessageEvent): => {\n      let wsResponse = convertMyAPIMessageToWSResponse(msg)\n      const event = new CustomEvent('sessionMsg', { detail: wsResponse});\n      qr..dispatchEvent(event);        \n    }\n\n    //TODO fix with your API Data\n    const convertMyAPIMessageToWSResponse = (msg: MessageEvent) :WSResponse => {\n      //Example: session created\n      //TODO Process Message and transform to WSResponse object\n      return {\n          sessionId: 'somesession';\n          result: RESULT_STATUS.ONGOING;\n        };\n    }\n\n      //TODO Use this if you need a client message to start the session request on your API\n    const requestSession = (socket) => {\n      socket.send(\"SESSION_REQUEST\")\n    }\n\n    const createSessionSuccess = (newdata: any) => {\n        //TODO Handle success\n    }\n\n    const createSessionError = (error: any) => {\n        //TODO Handle ERROR\n    }\n\n  //render() function in class components\n  return (\n      // @ts-ignore\n      <gataca-qrws\n          callback-server={ verifier ? YOUR_CONNECT_HOST: YOUR_CERTIFY_HOST }\n          socket-endpoint={YOUR_SERVICE}\n          ref={qr}\n          qr-role={verifier ? \"connect\":\"certify\"}\n      />\n    )\n}\n````\n\n### Angular App Integration\n\nTBD\n",
      "docs": "This component built using stencyl allows an easy integration to display a \"Quick SSI Access Button\", with a similar to the current existing sign-in buttons for OAuth2 providers like Google, Twitter or Facebook. The display is identical to the simple [Gataca-SSI Button](../gataca-ssibutton/readme.md), but with a component using websockets underneath.\n\nThis component wraps the logic to display and hide a Gataca-QR component under a button. To configure and integrate it, you need to follow the same process as the base [Gataca-QRWS Component](../gataca-qrws/readme.md). It is the suitable option if you wish to display an SSI Button but allowing the use of WebSockets instead of polling.\n\nThis component can be used with the prerequisite of having an application which can be integrated with GATACA Components: Connect and Certify. In this case, your application must offer a WebSocket communication.\n\nThe websocket service implemented by your service may be completely custom or use the following structure for messages -the type is exported by this library-:\n\n```typescript\nexport type WSResponse = {\n  sessionId: string;\n  result: RESULT_STATUS;\n  authenticatedUserData?: any;\n  authenticationRequest?: string;\n  error?: string;\n};\n```\n\nIf your WS Messages implement this interface, you need to know that the QR will start when a WS message is received with result === RESULT_STATUS.ONGOING (0) and a sessionId.\nThe QR will end when a message with a different result is received, depending on the result.\n\nIf your server wants to implement a different interface, there is no problem, but you need to trigger an Event named **sessionMsg** with a matching WSResponse in detail for the QR Component to understand (see examples).",
      "docsTags": [],
      "usage": {},
      "props": [
        {
          "name": "autorefresh",
          "type": "boolean",
          "mutable": false,
          "attr": "autorefresh",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nSet to refresh the session automatically upon expiration. By default it is false",
          "docsTags": [],
          "default": "false",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "autostart",
          "type": "boolean",
          "mutable": false,
          "attr": "autostart",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nSet to enable autoload when the QR is displayed. By default it is true",
          "docsTags": [],
          "default": "true",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "buttonText",
          "type": "string",
          "mutable": false,
          "attr": "button-text",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nIn the case of being a button, modifies its text",
          "docsTags": [],
          "default": "\"Easy login\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "callbackServer",
          "type": "string",
          "mutable": false,
          "attr": "callback-server",
          "reflectToAttr": false,
          "docs": "***Mandatory just for V1***\nConnect/Certify Server where the wallet will send the data",
          "docsTags": [],
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "dynamicLink",
          "type": "boolean",
          "mutable": false,
          "attr": "dynamic-link",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nDisplay a link containing a dynamic link to invoke the wallet if closed",
          "docsTags": [],
          "default": "true",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "errorCallback",
          "type": "(error?: Error) => void",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "***Mandatory***\nCallback fired upon session expired or invalid\nIf not set, session error would not be handled\nAn error containing information will be passed as parameter",
          "docsTags": [],
          "default": "undefined",
          "values": [
            {
              "type": "(error?: Error) => void"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "hideBrandTitle",
          "type": "boolean",
          "mutable": false,
          "attr": "hide-brand-title",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nBoolean to show or not show the gataca brand title",
          "docsTags": [],
          "default": "false",
          "values": [
            {
              "type": "boolean"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "qrModalDescription",
          "type": "string",
          "mutable": false,
          "attr": "qr-modal-description",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nModifies the Modal description",
          "docsTags": [],
          "default": "\"Sign up or sign in by scanning the QR Code with the Gataca Wallet\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "qrModalTitle",
          "type": "string",
          "mutable": false,
          "attr": "qr-modal-title",
          "reflectToAttr": false,
          "docs": "_[Optional]_\nModifies the qr headline title",
          "docsTags": [],
          "default": "\"Quick Access\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "qrRole",
          "type": "string",
          "mutable": false,
          "attr": "qr-role",
          "reflectToAttr": false,
          "docs": "***Mandatory***\nDecide if scanning the credential as a verifier to request credentials\nor as an issuer too issue credentials.\nOptions: connect | certify",
          "docsTags": [],
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "sessionTimeout",
          "type": "number",
          "mutable": false,
          "attr": "session-timeout",
          "reflectToAttr": false,
          "docs": "***Mandatory***\nMaximum time window to display the session and keep the websocket connection. It's needed to ensure the socket is closed.",
          "docsTags": [],
          "values": [
            {
              "type": "number"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "socketEndpoint",
          "type": "string",
          "mutable": false,
          "attr": "socket-endpoint",
          "reflectToAttr": false,
          "docs": "***Mandatory***\nWS Endpoint on your service to be invoked upon display",
          "docsTags": [],
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "successCallback",
          "type": "(data?: any) => void",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "***Mandatory***\nCallback fired upon session correctly verified\nIf not set, session validation wouldn't trigger any action\nThe session data and a possible token will be sent as parameters to the callback",
          "docsTags": [],
          "default": "undefined",
          "values": [
            {
              "type": "(data?: any) => void"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "v",
          "type": "string",
          "mutable": false,
          "attr": "v",
          "reflectToAttr": false,
          "docs": "**RECOMMENDED**\nIf 3, handle deeplink redirects and deprecates (remove) v1 functionality. If not, the create session must be providing both an authentication request and a session Id",
          "docsTags": [],
          "default": "\"3\"",
          "values": [
            {
              "type": "string"
            }
          ],
          "optional": true,
          "required": false
        },
        {
          "name": "wsOnMessage",
          "type": "(socket: WebSocket, msg: MessageEvent<any>) => void",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "**RECOMMENDED**\nCallback to invoke an a message has been received on the socket. It provides the socket itself and the message as parameters.\nIf not used, the messages provided by the server on the Socket connection must conform to the WSReponse interface\nIf used, an Event named **sessionMsg** must be triggered with a WSReponse as data",
          "docsTags": [],
          "values": [
            {
              "type": "(socket: WebSocket, msg: MessageEvent<any>) => void"
            }
          ],
          "optional": false,
          "required": false
        },
        {
          "name": "wsOnOpen",
          "type": "(socket: WebSocket) => void",
          "mutable": false,
          "reflectToAttr": false,
          "docs": "[Optional]\nFunction to send a message to the server upon socket creation",
          "docsTags": [],
          "values": [
            {
              "type": "(socket: WebSocket) => void"
            }
          ],
          "optional": false,
          "required": false
        }
      ],
      "methods": [
        {
          "name": "getSessionData",
          "returns": {
            "type": "Promise<any>",
            "docs": ""
          },
          "signature": "getSessionData() => Promise<any>",
          "parameters": [],
          "docs": "Retrieve manually the session data on a successful login",
          "docsTags": []
        }
      ],
      "events": [
        {
          "event": "gatacaLoginCompleted",
          "detail": "any",
          "bubbles": true,
          "cancelable": true,
          "composed": true,
          "docs": "GatacaLoginCompleted event, triggered with session data upon login success",
          "docsTags": []
        },
        {
          "event": "gatacaLoginFailed",
          "detail": "any",
          "bubbles": true,
          "cancelable": true,
          "composed": true,
          "docs": "GatacaLoginFailed event, triggered with error upon login failure",
          "docsTags": []
        }
      ],
      "listeners": [],
      "styles": [],
      "slots": [],
      "parts": [],
      "dependents": [
        "gataca-autoqr"
      ],
      "dependencies": [
        "gataca-qrws"
      ],
      "dependencyGraph": {
        "gataca-ssibuttonws": [
          "gataca-qrws"
        ],
        "gataca-qrws": [
          "gataca-qrdisplay"
        ],
        "gataca-autoqr": [
          "gataca-ssibuttonws"
        ]
      }
    }
  ]
}